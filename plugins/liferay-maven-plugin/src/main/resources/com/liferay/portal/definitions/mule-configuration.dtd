<!--
 Copyright (c) MuleSource, Inc.  All rights reserved.  http://www.mulesource.com

 The software in this package is published under the terms of the CPAL v1.0
 license, a copy of which has been included with this distribution in the
 LICENSE.txt file.

 This DTD describes the grammar of the Mule configuration properties.

 $Date: 2007-08-21 16:26:13 +0200 (Tue, 21 Aug 2007) $
 $Revision: 7976 $

 @root mule-configuration
-->

<!ELEMENT mule-configuration (description?,environment-properties?,mule-environment-properties?,container-context*,security-manager?,
 transaction-manager?,agents?,connector*,endpoint-identifiers?,transformers?,global-endpoints?,
            interceptor-stack*,model*)>

<!--
    The id attribute allows for a unique id for this file as it is often the case that
    distributed Mule environments have their own properties
-->
<!ATTLIST mule-configuration id              NMTOKEN         #IMPLIED>
<!--
    The version attribute is used to bind a mule_props.xml
    file to a given version of this dtd. This will help to
    avoid versions conflicts.
-->
<!ATTLIST mule-configuration version    (1.0)           #REQUIRED>

<!--
    <i>mule-environment-params</i> are prarameters used by the Mule run-time. If none or not all
    parameters are specified defaults will be used
-->
<!ELEMENT mule-environment-properties (threading-profile*, pooling-profile?, queue-profile?, persistence-strategy?, connection-strategy?)>

<!--
    Specifies whether mule should process messages sysnchonously, i.e. that a mule-model
    can only processone message at a time, or asynchonously.  The default value is
    'false'.
-->

<!ATTLIST mule-environment-properties synchronous                     (true | false)          "false">
<!--
    A property file can specify more than one mule-model.  In the situation when more than
    one is difined this property tells Mule which model to load.  If this is not specifed
    the first model is used.
    <strong>This property currently is not used</strong>
-->
<!ATTLIST mule-environment-properties model                            CDATA                    #IMPLIED>

<!--
     The directory where mule can write any temporary files or persist messages
-->
<!ATTLIST mule-environment-properties workingDirectory          CDATA                 "./.mule">

<!--
     When running sychonously, return events can be received over transports that support ack or replyTo
     This property determines how long to wait for a receive
-->
<!ATTLIST mule-environment-properties synchronousEventTimeout          NMTOKEN                 #IMPLIED>

<!--
     Added default encoding to use for general parsing of strings
-->
<!ATTLIST mule-environment-properties encoding          CDATA                 #IMPLIED>
<!--
     Added default os encoding to use for general system message formatting and web service and servlet encoding
-->
<!ATTLIST mule-environment-properties osEncoding          CDATA                 #IMPLIED>

<!--
     Default transaction timeout
-->
<!ATTLIST mule-environment-properties transactionTimeout          NMTOKEN                 #IMPLIED>

<!--
     Determines whether when running synchronously, return events are received before
     returning the call. i.e. in jms wait for a replyTo. Vm queues do this automatically
-->
<!ATTLIST mule-environment-properties remoteSync          (true | false)          "false">

<!--
     Determines if Mule is running embedded and can be used to disable certain services and also hide the
     start splash
-->
<!ATTLIST mule-environment-properties embedded          (true | false)          "false">

<!--
     Is the default endpointUri where Mule can receive Action requests such as running a
     send, dispatch or receive request from a remote client. If not specified the default will
     be used of tcp://localhost:60504.
     Note users can explicitly configure the MuleManagerComponent that serves these type of
     requests and this variable need not be set. Setting this to an empty string
     "" will disable the server admin component.  Often client only and test configurations
     will want to do this.
-->
<!ATTLIST mule-environment-properties serverUrl                      CDATA          #IMPLIED>

<!--
     Determines whether Mule's internal queues are persisted.  If the server dies unexpectedly Mule
     can resume processing when the server starts
-->
<!ATTLIST mule-environment-properties recoverableMode           (true | false)          "false">

<!--
     Determines whether Mule amule instance is runnig in client mode.  client mode means that
     certain Mule Manager services are not started suhc as the the Admin component and the Server
     event manager.  The only time a user would need to set variable explicitly is if they
     where configuring a Mule instance via Xml config for client-only usage.
-->
<!ATTLIST mule-environment-properties clientMode           (true | false)          "false">

<!--
    Whether mule should fire message events for every message sent and received
-->
<!ATTLIST mule-environment-properties enableMessageEvents           (true | false)          "false">

<!--
    The type of model used for the internal system model where system created services are registered
-->
<!ATTLIST mule-environment-properties systemModelType           CDATA        "seda">
<!--
A pooling profile is used to configure the pooling behaviour of UMO components.
each descriptor can set it's own pooling profile or a default one can be set
on the mule-configuration.
-->

<!ELEMENT pooling-profile EMPTY>

<!--
    Controls the maximum number of Mule UMOs that can be borrowed from a Session at one time.
    When non-positive, there is no limit to the number of components that may be active at one time.
    When maxActive is exceeded, the pool is said to be exhausted.
    You can specify this value on the descriptor declaration. If none is set this value
    will be used.
-->
<!ATTLIST pooling-profile maxActive                NMTOKEN                 #IMPLIED>

<!--
    Controls the maximum number of Mule UMOs that can sit idle in the pool at any time. When non-positive,
    there is no limit to the number of Mule UMOs that may be idle at one time.
    You can specify this value on the descriptor declaration. If none is set this value
    will be used.
-->

<!ATTLIST pooling-profile maxIdle                  NMTOKEN                 #IMPLIED>
<!--
    Determines how components in a pool should be initialised. the possible values are -
    <ul>
        <li>INITIALISE_NONE : Will not load any components into the pool on startup</li>
        <li>INITIALISE_ONE : Will load one initial component into the pool on startup</li>
        <li>INITIALISE_ALL : Will load all components in the pool on startup</li>
    </ul>
   The default for this value is INITIALISE_ONE.
   <p>
   The value INITIALISE_FIRST is deprecated; use INITIALIZE_ONE.
-->
<!ATTLIST pooling-profile initialisationPolicy    (INITIALISE_NONE | INITIALISE_ONE | INITIALISE_FIRST | INITIALISE_ALL)    "INITIALISE_ONE">
<!--
     Specifies the behaviour of the Mule UMO pool when the pool is exhausted:
      <ul>
      <li>WHEN_EXHAUSTED_FAIL : will throw a NoSuchElementException</li>
      <li>WHEN_EXHAUSTED_WAIT: will block (invoke Object.wait(long) until a new or idle object is available.<li>
      <li>WHEN_EXHAUSTED_GROW : will create a new Mule and return it(essentially making maxActive meaningless.)</li>
     </ul>
     If a positive maxWait value is supplied, it will block for at most that many milliseconds,
     after which a NoSuchElementException will be thrown. If maxWait is non-positive, it will block
     indefinitely.
     <p>
     The values FAIL, WAIT, BLOCK and GROW are deprecated.
-->
<!ATTLIST pooling-profile exhaustedAction    (WHEN_EXHAUSTED_GROW | GROW | WHEN_EXHAUSTED_WAIT | WAIT | BLOCK | WHEN_EXHAUSTED_FAIL | FAIL)    "WHEN_EXHAUSTED_GROW">
<!--
Specifies the number of milliseconds to wait for a pooled component to become available
when the pool is exhausted and the exhaustedAction is set to 'wait'.
-->
<!ATTLIST pooling-profile maxWait          NMTOKEN                    #IMPLIED>

<!--
A fully qualified classname of the pool factory to use with this pool profile.
Implementations must implement org.mule.umo.UMOPoolFactory.
-->
<!ATTLIST pooling-profile factory          NMTOKEN                    "org.mule.config.pool.CommonsPoolFactory">


<!ELEMENT threading-profile EMPTY>

<!--
The threading profile system id.  This is used to identify which system
component should use the profile. This attribute is only used when declaring profiles on
the mule-evironment-properties element and on connector components where 'messageReceiver'
or 'messageSender' can be used. For all other cases it can be set to 'default'.
-->
<!ATTLIST threading-profile id  (receiver|dispatcher|component|default)  "default">

<!--
Controls the maximum number of threads that can be executed at any one time in a
thread pool
-->
<!ATTLIST threading-profile maxThreadsActive                NMTOKEN                 #IMPLIED>

<!--
Controls the maximum number threads that can be inactive or idle in a thread pool before
they are destroyed.
-->

<!ATTLIST threading-profile maxThreadsIdle                  NMTOKEN                 #IMPLIED>
<!--
Detemines how long an inactive thread is kept in the pool before being discarded
-->
<!ATTLIST threading-profile threadTTL                   NMTOKEN                 #IMPLIED>
<!--
If the maximum pool size or queue size is bounded, then it is possible for incoming execute requests to block.
There are five supported policies for handling this situation.

<ul>
<li>WHEN_EXHAUSTED_RUN (the default) - The thread making the execute request runs the task itself.
 This policy helps guard against lockup.
</li>
<li>WHEN_EXHAUSTED_WAIT - Wait until a thread becomes available (or until the configurable timeout expires).
This policy should, in general, not be used if the minimum number of threads is zero, in
 which case a thread may never become available.
</li>
<li>WHEN_EXHAUSTED_ABORT - Throw a RuntimeException
</li>
<li>WHEN_EXHAUSTED_DISCARD  - Throw away the current request and return.
</li>
<li>WHEN_EXHAUSTED_DISCARD_OLDEST - Throw away the oldest request and return.
</li>
</ul>
The shorthand values WAIT, DISCARD, DISCARD_OLDEST, ABORT and RUN are deprecated; please use their canonical equivalents.
-->

<!ATTLIST threading-profile poolExhaustedAction     (WAIT | DISCARD | DISCARD_OLDEST | ABORT | RUN)       "RUN">

<!--
Allows configuration of a waiting timeout for threads that are blocked when WAIT
has been configured as poolExhaustedAction
-->
<!ATTLIST threading-profile threadWaitTimeout    NMTOKEN    #IMPLIED>

<!--
Determines whether threading is enabled for a connector.  It's useful to set this to false
when testing.  Setting it on the defaultThreadingProfile on the Mule configuration will disable
threading in every connector
-->
<!ATTLIST threading-profile doThreading     (true | false)       "true">

<!--
    Determines how many requests if any are queue when the pool is at maximum
    usage capacity.  The buffer is used as an overflow.
-->
<!ATTLIST threading-profile maxBufferSize   NMTOKEN         #IMPLIED>

<!--
    A Queue Profile is used to describe the the properties of an internal Mule queue. Internal queues are used to
    queue events for each component managed by Mule.
-->

<!ELEMENT queue-profile (properties?)>

<!--
    Defines the maximum number of message that can be queued.
-->
<!ATTLIST queue-profile maxOutstandingMessages   NMTOKEN         #IMPLIED>

<!--
    Defines if this queue is persistent or not
-->
<!ATTLIST queue-profile persistent   (true | false)         "false">

<!--
   A persistence strategy defines the mechanism used to store Mule events to a persistent store.  Primarily, this
   is used for for persisting queued events to disk so that the servers internal state is mirrored on disk in case
   the server fails and needs to be restarted.
-->
<!ELEMENT persistence-strategy (properties?)>

<!--
    A fully qualified class name of the org.mule.util.queue.PersistenceStrategy implementation to use to store
    mule events.
-->
<!ATTLIST persistence-strategy className   NMTOKEN         #REQUIRED>

<!--
    The environment-param element allows to add custom properties.  These are accessible
    from the MuleManager getProperty method
  -->
<!ELEMENT environment-properties ((property | factory-property | system-property | map | list | file-properties)+)>

<!--
    This element specifies the transaction manager to use (if any) in the Mule Server
    The configuration must specify a factory attribute which is a fully qualified class
    name of a Transaction factory that implements org.mule.umo.manager.UMOTransactionManagerFactory

  -->
<!ELEMENT transaction-manager (properties?)>

<!--
    The <i>factory</i> specifies the transaction manager factory to use to
    create a transaction manager for the Mule server

    The <i>property</i> element allows to add custom attributes.  Each of the
    key value pair attributes will be passed to the connection as a HashMap
    The connection implementation will then handle how these properties are set.
-->

<!ATTLIST transaction-manager factory                NMTOKEN                 #IMPLIED>

<!--
The ref name of this object if it is to be loaeded from a container such as spring or
Jndi
-->
<!ATTLIST transaction-manager ref                     CDATA                 #IMPLIED>

<!--
    This element specifies the security manager to use (if any) for this Mule Server instance
    The security manager is responsible for managing one or more security providers that can
    validate user credentials

  -->
<!ELEMENT security-manager (security-provider*, encryption-strategy*)>

<!--
    The <i>className</i> is optional and specifies the security manager to use.
-->

<!ATTLIST security-manager className                NMTOKEN                 #IMPLIED>

<!--
The ref name of this object if it is to be loaeded from a container such as spring or
Jndi
-->
<!ATTLIST security-manager ref                     CDATA                 #IMPLIED>

<!--
   A security provider allows credentials to be authenticated against various credential
   providers.
-->
<!ELEMENT security-provider (properties?)>

<!--
 A fully qualified class name of the security provider to use
 -->
<!ATTLIST security-provider className                NMTOKEN                 #IMPLIED>

<!--
The ref name of this object if it is to be loaeded from a container such as spring or
Jndi
-->
<!ATTLIST security-provider ref                     CDATA                 #IMPLIED>

<!--
 A unique name that identifies the security provider
 -->
<!ATTLIST security-provider name                ID                 #REQUIRED>

<!--
   A encryption strategy is a encryption configuration object that
   can be used by mule components to perform en/decryption.  The main
   components that will use these strategies are security filters and
   transformers
-->
<!ELEMENT encryption-strategy (properties?)>

<!--
 A fully qualified class name of the encryption strategy to use
 -->
<!ATTLIST encryption-strategy className                NMTOKEN                 #REQUIRED>

<!--
 A unique name that identifies the encryption strategy
 -->
<!ATTLIST encryption-strategy name                ID                 #REQUIRED>

<!--
The <i>connector</i> element specifies one or more message
  connections for Mule components.
-->

<!ELEMENT connector (properties?, threading-profile?, exception-strategy?, connection-strategy?)>

<!--
    The name attribute is used to bind a connection to a logical name in the system
    This must be unique for each Mule instance
-->

<!ATTLIST connector name                 ID        #REQUIRED>
<!--
    The fully qualified classname to instanciate the connector with
-->
<!ATTLIST connector className            NMTOKEN        #IMPLIED>

<!--
The ref name of this object if it is to be loaeded from a container such as spring or
Jndi
-->
<!ATTLIST connector ref                     CDATA                 #IMPLIED>

<!--
The <i>connection-strategy</i> element specifies a strategy implementation used when making
a connection to the underlying resource
-->

<!ELEMENT connection-strategy (properties?)>

<!--
    The fully qualified classname to instanciate the connector strategy. This class must
    implement <i>org.mule.providers.ConnectionStrategy</i>
-->
<!ATTLIST connection-strategy className            NMTOKEN        #REQUIRED>

<!--
    This is a grouping element for individual <i>endpoint-identifier</i> instances
-->

<!ELEMENT endpoint-identifiers (endpoint-identifier+)>

<!--
    A <i>endpoint-identifier</i> is a mapping between an endpoint and a logical name.  The MuleManager
    provides an interface to lookup these endpoints. Essentially this is just a key value
    pair i.e.  you may map -
    <ul>
        <li>Fault Email -&gt; smtp://admin&#64;mycompany.com</li>
        <li>Shipping Manager  -&gt; jms://shipping.orders.topic</li>
        <li>Administrators Mobile -&gt; sms://+447910010010</li>
    </ul>
-->

<!ELEMENT endpoint-identifier EMPTY>

<!--
    name
    The logical endpoint name
-->
<!ATTLIST endpoint-identifier name         CDATA            #REQUIRED>
<!--
    value
    The corresponding endpoint value
-->
<!ATTLIST endpoint-identifier value        CDATA            #REQUIRED>

<!--
    A grouping element for all transformer declarations
-->
<!ELEMENT transformers (transformer+)>

<!--
    Transformers are used to convert objects from one type to another.  mule-descriptors
    can be associated with two transformers: one for inbound messages and one of
    outbound messages.
    All transformers must implement <i>org.mule.transformers.Transformer</i>

        The <i>org.mule.doCompression</i> property determines whether a transformer should
        compress/uncompress its data.  This attribute is ignored unless the
        transformer named in the className attribute extends
        <i>org.mule.transformers.compression.AbstractCompressionTransformer</i>
        This is a fairlycommon property but must be specified on the transformer
        declaration as a property i.e.

        <code>
        &lt;transformer name="ObjectToJMSMessage" className="org.mule.transformers.ObjectToJMSMessage" returnClass="javax.jms.BytesMessage"&gt;
            &lt;properties&gt;
                &lt;property name="org.mule.doCompression" value="true"/&gt;
            &lt;/properties&gt;
        &lt;/transformer&gt;
        </code>
-->

<!ELEMENT transformer (properties?)>

<!--
        name
        The logical name for the transformer.  When the transformer is
        registered it's name will be used to reference the transformer.
        If this attibute is not set then it will default to it's class
        name without the pakage prefix.
-->
<!ATTLIST transformer name                      ID                #REQUIRED>
<!--
    The className attribute represents the full qualified class name
    of the Transformer implementation
 -->
<!ATTLIST transformer className               NMTOKEN             #IMPLIED>

<!--
The ref name of this object if it is to be loaeded from a container such as spring or
Jndi
-->
<!ATTLIST transformer ref                     CDATA                 #IMPLIED>

<!--
        The returnClass attribute represents the full qualified class name
        of the expected return Object of the Transformer implementation. if none is
        specified java.lang.Object is used by default. However, by suppling a returnClass
        the transformer can validate that the returnObject is of expected type before return
        to the callee.
-->
<!ATTLIST transformer returnClass             CDATA             "java.lang.Object">

<!--
    Determines whether the tranformer should through an exception if an incompatible source type
    is received or whether to ignore it so that the next transformer can be invoked
 -->
<!ATTLIST transformer ignoreBadInput          (true|false)             #IMPLIED>

<!--
    <i>global-endpoints</i> are endpoint configurations made available to all components in
    a model through the MuleManager. This is a grouping element for individual
    <i>endpoint</i> instances

-->
<!ELEMENT global-endpoints (endpoint+)>

<!--

    A <i>endpoint</i> are communication channel definitions to some message system.  These
    are used to publish and subscibe messages in and outside of Mule

    If the endpoint is of type receiver The filter is used to filter incoming
    events.  Not all endpoint providers support filtering so if a filter is set on an endpoint
    that uses a provider that doesn't support filtering an UnsupportedOperationException
    is thrown.

    The property element allows to add custom attributes to the endpoint.

-->

<!ELEMENT endpoint ((transaction)?, (filter)?, (security-filter)?, (properties)?)>

<!--
    The name attribute is used to bind a <i>endpoint</i> to a logical name in the system
    This must be unique for each Mule instance. If not set one will be generated
-->

<!ATTLIST endpoint name         ID            #IMPLIED>

<!--
The ref name of this object if it is to be loaeded from a container such as spring or
Jndi
-->
<!ATTLIST endpoint ref                     CDATA                 #IMPLIED>
<!--
    This specifes the communication endpoint.  This will have a different format depending
    on the transport protocol being used i.e.
    <ul>
        <li>smtp -&gt; admin&#64;mycompany.com</li>
        <li>jms  -&gt; shipping.orders.topic</li>
        <li>sms  -&gt; +447910010010</li>
    </ul>

    if an endpoint address is not specifed it will be assumed that it will be determined at run-time
    by the calling application.  The endpoint address must be a URI address or it can be a logical name for an
    endpoint as long as it is declared in a <i>endpoint</i> block.
    Example uris are:
    <ul>
        <li>vm://test.queue?transformers=ObjectToXml</li>
        <li>pop3://ross:password@mail.muleumo.org?createConnector=ALWAYS</li>
        <li>file:///C:/temp/mule?transformers=FileMessageToObject</li>
    </ul>
-->

<!ATTLIST endpoint address        CDATA            #REQUIRED>
<!--
    The name of connector to use for this endpoint.  The protocol of the connector
    named must match the protocol of the endpoint address.  If this value is not set
    the first connector found with the correct protocol will be used
-->
<!ATTLIST endpoint connector    CDATA           #IMPLIED>
<!--
    Determines whether the endpoint provider is a sender, receiver or a senderAndReceiver.
    An endpoint can be senderAndReceiver meaning that there is no difference for the endpoint
    configuration if it is used as a sender or receiver.

-->
<!ATTLIST endpoint type        (sender | receiver | senderAndReceiver)     "senderAndReceiver">

<!--
    Is responsible for transforming data when it is received or sent by the UMO
    (depending on whether this endpoint is a receiver or not). A tranformation for an
    inbound event can be forced by the user by calling the inbound event.getTransformedMessage().
    A tranformation for an outbound event is called or when the UMO dispatchEvent()
    or sendEvent() methods are called.
-->
<!ATTLIST endpoint transformers    CDATA            #IMPLIED>


<!--
    Is responsible for transforming data when it is returned from a request/response
    invocation. If the endpoint is a receiver the responseTransformers is ignored.
-->
<!ATTLIST endpoint responseTransformers    CDATA            #IMPLIED>

<!--
    synchronous
    determines if requests received on this endpoint execute within a single thread
    if not set the MuleManager synchronous property will be used
-->
<!ATTLIST endpoint synchronous    (true|false)            #IMPLIED>

<!--
    streaming
    Whether this endpoint will stream data in/out of mule
-->
<!ATTLIST endpoint streaming    (true|false)            #IMPLIED>

<!--
    encoding
    explicitly specify the encoding used by this endpoint
-->
<!ATTLIST endpoint encoding          CDATA                 #IMPLIED>

<!--
    remoteSync
    Determines whether when running synchronously, return events are received before
    returning the call. i.e. in jms wait for a replyTo or tcp/http reply on the outputStream.
    Vm queues do this automatically
-->
<!ATTLIST endpoint remoteSync    (true|false)            #IMPLIED>

<!--
    remote-sync-timeout
    How long to block for a remote sync operation
-->
<!ATTLIST endpoint remoteSyncTimeout    NMTOKEN            #IMPLIED>


<!--
    Deterimes how mule will allocate a connector for this endpoint.  By default
    Mule will look for a connector with a protocol matching the protocol of the address
    of this endpoint.  If a match is found that connector will be used, otherwise a new
    connector will be created. Users can specify ALWAYS to aleways create a new connector
    or NEVER which will require a connector to be pre-configured.
-->
<!ATTLIST endpoint createConnector    (GET_OR_CREATE | ALWAYS_CREATE | NEVER_CREATE)       #IMPLIED>

<!--
    A global endpoint reference
-->
<!ELEMENT global-endpoint (transaction?, filter?, security-filter?, properties*)>

<!--
    name
    The name of the global referene to use
-->
<!ATTLIST global-endpoint name    CDATA            #REQUIRED>

<!--
    address
    Used to override the address on the global endpoint
-->
<!ATTLIST global-endpoint address    CDATA            #IMPLIED>

<!--
    address
    Used to override the transformers on the global endpoint
-->
<!ATTLIST global-endpoint transformers    CDATA            #IMPLIED>

<!--
    Is responsible for transforming data when it is returned from a request/response
    invocation. If the endpoint is a receiver the responseTransformers is ignored.
-->
<!ATTLIST global-endpoint responseTransformers    CDATA            #IMPLIED>

<!--
    synchronous
    determines if requests received on this endpoint execute within a single thread
    if not set the MuleManager synchronous property will be used
-->
<!ATTLIST global-endpoint synchronous    (true|false)            #IMPLIED>

<!--
    remote-sync
    Determines whether when running synchronously, return events are received before
    returning the call. i.e. in jms wait for a replyTo or tcp/http reply on the outputStream.
    Vm queues do this automatically
-->
<!ATTLIST global-endpoint remoteSync    (true|false)            #IMPLIED>

<!--
    remote-sync-timeout
    How long to block for a remote sync operation
-->
<!ATTLIST global-endpoint remoteSyncTimeout    NMTOKEN            #IMPLIED>

<!--
    encoding
    explicitly specify the encoding used by this endpoint
-->
<!ATTLIST global-endpoint encoding          CDATA                 #IMPLIED>

<!--
A security filter ensures that all requestsmade via an endpoint will be authenticated
-->
<!ELEMENT security-filter (properties?)>

<!--
By default, all providers registered with the security manager will be
authenticated against.  However a space separated list of provider names can
be specified to change the order or the restrict the list of security
providers used.
-->
<!ATTLIST security-filter useProviders    CDATA            #IMPLIED>

<!--
A fully qualified classname of the security filter to use on this endpoint
-->
<!ATTLIST security-filter className    NMTOKEN            #REQUIRED>

<!--
    Defines transactional behaviour for this endpoint
-->

<!ELEMENT transaction (constraint?)>

<!--
    The factory attribute defines the <i>UMOTransactionFactory</i> to use when creating new
    transactions. This is only require when the transaction config is declared on an inbound
    provider.
-->

<!ATTLIST transaction factory         NMTOKEN            #IMPLIED>

<!--
    The Action attribute determise the way that the provider demarcates
    transactions when it receives an event.

    NONE - tells the provider not to do anything regarding transaction management.
    ALWAYS_BEGIN - Will always start a new transaction when an event is received.
    BEGIN_OR_JOIN - Will join the transaction if one is in progress otherwise one will be started.
    ALWAYS_JOIN - Expects a transaction to be in progress and joins it.
    JOIN_IF_POSSIBLE - Will join a transaction if one is in progress others just continues processing.

-->

<!ATTLIST transaction action         (NONE | ALWAYS_BEGIN |
                                        BEGIN_OR_JOIN | ALWAYS_JOIN |
                                        JOIN_IF_POSSIBLE )                 #IMPLIED>

<!--
    The commitAction attribute determines how transactions are managed when an event is published.

    NONE - tells the provider not to do anything regarding transaction management.
    ALWAYS_COMMIT - Will expect a transaction to be in process and will commit it.
    JOIN_IF_POSSIBLE - Will commit a transaction if one is in progress others just continues processing.

-->

<!--<!ATTLIST transaction commitAction         (NONE | ALWAYS_COMMIT | COMMIT_IF_POSSIBLE )            #IMPLIED>-->

<!--
    Transaction timeout for transactions initiated from the endpoint associated with
    this transaction config.
-->

<!ATTLIST transaction timeout         NMTOKEN            #IMPLIED>

<!--
    Constraints can be defined on a send provider to control how and when a transaction
    gets committed.  For example, to commit a transaction once 3 jms messages have been
    processed you can define a BatchConstraint on the transaction and set the batch size to 3.
    These constraints work the same way as filters and properties on the filters can be set
    as attributes on the filter xml element.
-->
<!ELEMENT constraint (left-filter?,right-filter?, filter?)>

<!--
    className
    A fully qualified class name of the filter Constraint to use.  Implementations should always
    implement <i>org.mule.umo.UMOFilter</i>.
-->
<!ATTLIST constraint className          NMTOKEN         #REQUIRED>

<!--
because I can't find a way of allowing arbitary attributes on an element,
I am going to define a common set of attributes for filters but users can add their own
or relax dtd validation on their parser.
-->
<!ATTLIST constraint batchSize                 NMTOKEN         #IMPLIED>
<!ATTLIST constraint frequency                 CDATA           #IMPLIED> <!-- milliseconds -->
<!ATTLIST constraint expectedType              CDATA           #IMPLIED>
<!ATTLIST constraint path                      CDATA           #IMPLIED>
<!ATTLIST constraint pattern                   CDATA           #IMPLIED>
<!ATTLIST constraint expression                CDATA           #IMPLIED>


<!--
  Interceptors can be executed in sequence before and/or after the Mule component.
  A <i>interceptor-stack/i> is a stack of interceptors that can be assigned to multiple
  Mule components to provide standard functionality.
-->

<!ELEMENT interceptor-stack (interceptor+)>
<!--
    The idenfying name for the interceptor stack
-->

<!ATTLIST interceptor-stack name             ID         #REQUIRED>

<!--
Agents is a collection of one or more agent configurations
-->

<!ELEMENT agents (agent+)>

<!--
    An agent is a server plugin that can be initialised stated and destroyed along with the UMOManager itself.
    Agents can initialise or bind to external services such as Jmx server
-->
<!ELEMENT agent (properties?)>

<!--
    Unique name for the agent
-->
<!ATTLIST agent name             CDATA         #REQUIRED>

<!--
    The fully qualified classname of the Agent
-->
<!ATTLIST agent className             NMTOKEN         #IMPLIED>
<!--
The ref name of this object if it is to be loaeded from a container such as spring or
Jndi
-->
<!ATTLIST agent ref                     CDATA                 #IMPLIED>

<!--
    A Container context is used to retrieve object properties from the container.
    A container property is referenced using the container-property element.
    There are different implementations for different containers
    such as PicoContainer or Spring
-->
<!ELEMENT container-context (properties?)>

<!--

    The fully qualified class name of the container context.  Customer contexts must implement
    <i>org.mule.umo.UMOContainerContext</i>.
    Configuration of the container itself should be provided though properties on this
    element.
-->
<!ATTLIST container-context className      NMTOKEN        #REQUIRED>

<!--
    The name of this container context.  Containers have a default name, which
    is usually the the name of the container implementation
-->
<!ATTLIST container-context name      CDATA        #IMPLIED>

<!--
    The <i>model</i> defines the components and interations between components in the Mule
    run-time environment.  Here is specified which components exist in the system and how they
    should behave.
-->

<!ELEMENT model (description?, entry-point-resolver?, component-factory?, component-lifecycle-adapter-factory?, component-pool-factory?, exception-strategy?, mule-descriptor*, bean*)>

<!--
    The name to associate this mule-model with
-->

<!ATTLIST model name              CDATA        #REQUIRED>

<!--
The ref name of this object if it is to be loaeded from a container such as spring or
Jndi
-->
<!ATTLIST model ref                     CDATA                 #IMPLIED>

<!--
The type of Model to use for component processing for this Mule instance.  The different types of model are described
at http://mule.mulesource.org/wiki/display/MULE/Models
The custom model can be used to specify a custom model type.  In which case you must supply a className.
-->
<!ATTLIST model type           (seda | direct | pipeline | jms | custom | streaming | inherited)             "seda">

<!--
    The class used for instanciate the model if a custom model type is being used.  The class must implement
    org.mule.umo.model.UMOModel.
-->

<!ATTLIST model className              NMTOKEN        #IMPLIED>
<!--
    An entry Point resolver is used to determine which method on a UMO object
    should receive events
-->
<!ELEMENT entry-point-resolver (properties?)>

<!--
    The fully qualified class name of the resolver to use on this model
-->

<!ATTLIST entry-point-resolver className          NMTOKEN        #REQUIRED>

<!--
    A Lifecycle adapter factory for creating a LifecycleAdapter for UMO componenets.
    This allows customer lifecycle event behaviour for UMO components.
-->
<!ELEMENT component-lifecycle-adapter-factory EMPTY>

<!--
    The fully qualified class name of the lifecycle adapterfactory.  Custom lifecycle adapters
    must implement <i>org.mule.umo.lifecycle.UMOLifecycleAdapterFactory</i>
-->

<!ATTLIST component-lifecycle-adapter-factory className          NMTOKEN        #REQUIRED>

<!--
    A component factory is used to create UMOComponent instances.  These are used to
    wrap business objects and controls how events are managed for the object
-->
<!ELEMENT component-factory EMPTY>

<!--
    The fully qualified class name of the component factory implementation.
    Custom component factories must implement
    <i>org.mule.umo.UMOcomponentFactory</i>
-->

<!ATTLIST component-factory className          NMTOKEN        #REQUIRED>

<!--
    An component pool factory is used to determine what pool implementation should be used by mule to
    pool UMOComponent instances.  Mule ships with  Pico pool (picoContainer) and commons pool(jakarta)
    implementations
-->
<!ELEMENT component-pool-factory (properties?)>

<!--
    The fully qualified class name of the component pool factory to use on this model
-->

<!ATTLIST component-pool-factory className          NMTOKEN        #REQUIRED>


<!--
    A <i>mule-descriptor</i> describes a single mule component, a MuleUMO. a component is an autonomous
    unit that executes a particular function by receiving an input doing some processing
    on the input and outputig a result, thus triggering futher events in the system.
-->

<!ELEMENT mule-descriptor ((inbound-router)?, (nested-router)?, (outbound-router)?, (response-router)?, (interceptor)*, (threading-profile)?, (pooling-profile)?, (queue-profile)?, (exception-strategy)?, (properties)?)>

<!--
    name
    The name to associate with the mule-descriptor
-->

<!ATTLIST mule-descriptor name                             CDATA           #REQUIRED>

<!--
The ref name of this object if it is to be loaded from a container such as spring or
Jndi
-->
<!ATTLIST mule-descriptor ref                     CDATA                 #IMPLIED>

<!--
    The transformer to use when receiving events on the specified inboundProvider.
    This property is deprecated, please use "inboundRouter" instead (see MULE-506).
-->
<!ATTLIST mule-descriptor inboundTransformer            CDATA            #IMPLIED>

<!--
    The transformer to use when receiving events on the specified outboundProvider.
    This property is deprecated, please use "outboundRouter" instead (see MULE-506).
-->
<!ATTLIST mule-descriptor outboundTransformer            CDATA            #IMPLIED>

<!--
    The transformer to use when sending events back.
    This property is deprecated, please use "responseRouter" instead (see MULE-506).
-->
<!ATTLIST mule-descriptor responseTransformer            CDATA            #IMPLIED>

<!--
    The class of the object or an object reference of the component being registered as an UMO.
    If the implementation is an object reference then it will be resolved using the component resolver
    configured on the model
-->
<!ATTLIST mule-descriptor implementation                CDATA         #REQUIRED>
<!--
    The default endpoint that the Mule UMO uses to receive events.
    This property is deprecated, please use "inboundRouter" instead (see MULE-506).
-->
<!ATTLIST mule-descriptor inboundEndpoint                CDATA            #IMPLIED>

<!--
    The default endpoint that the Mule UMO uses to send events.
    This property is deprecated, please use "outboundRouter" instead (see MULE-506).
-->
<!ATTLIST mule-descriptor outboundEndpoint                    CDATA            #IMPLIED>

<!--
    The version on the Mule UMO.  This is currently not used by the mule run-time but may
    be used in future
-->
<!ATTLIST mule-descriptor version                         NMTOKEN         #IMPLIED>

<!--
    This property is deprecated, please use "container" instead (see MULE-812).
<!ATTLIST mule-descriptor containerManaged            (true | false)            "true">
-->

<!--
    If an IoC container is being used this property can be set to determine which container explicitly
    the component should be loaded from. Also you can specify to not load the component from a Container
    context by setting this value to 'none'.
-->
<!ATTLIST mule-descriptor container            NMTOKEN        #IMPLIED>

<!--
    Determines if only a single instance of this component is created.  This is useful when a
    component hands off event processing to another engine such as Rules processing or Bpel
    and the processing engine allocates and manages its own threads.
-->
<!ATTLIST mule-descriptor singleton            (true | false)            "false">

<!--
    Determines the running state of a component when the model starts up
-->
<!ATTLIST mule-descriptor initialState            (started | stopped )            "started">

<!--
    TODO RM at the moment there seems to be no way to customise the model name,
    as it's forcefully set in MuleXmlConfigurationBuilder.
    A model name this service belongs to
-->
<!-- <!ATTLIST mule-descriptor modelName            CDATA            #IMPLIED> -->

<!--
    A message router configures different routing paths for events that are dispatched for a UMO
    component. An outbound router is concerned with messages/events being sent out from a UMO component.
    You can specify diferent routing rules for different providers configured on the
    mule-descriptor.  You can also chain routers together by embedding one router declaration inside
    the other
-->
<!ELEMENT outbound-router (catch-all-strategy?, router+)>

<!--
Whether every configured router will be matched against
-->
<!ATTLIST outbound-router matchAll               (true | false)           "false">

<!--
   A message router configures different routing paths for events that are dispatched for a UMO
    component. An inbound router is concerned with messages/events being received by providers configured
    on the mule-descriptor.
-->
<!ELEMENT inbound-router ((catch-all-strategy)?,(endpoint)*,(global-endpoint)*,(router)*)>

<!--
Whether every configured router will be matched
-->
<!ATTLIST inbound-router matchAll               (true | false)           "false">

<!--
 A nested router allows for mule orchestration of component dependencies
-->
<!ELEMENT nested-router ((binding)*)>

<!--
Configuration that binds and endpoint to an interface
-->
<!ELEMENT binding ((endpoint | global-endpoint))>

<!--
The fully qualified name of the interface class that will be proxied to call out to an endpoint
 if the interface has more than one method then the method param must also be set.
 -->
<!ATTLIST binding interface NMTOKEN #REQUIRED>

<!--
The name of the method that will be bound to the endpoint
-->
<!ATTLIST binding method NMTOKEN #IMPLIED>

<!--
   A message router configures how a resonse message will be routed to a client when
   using request/response message processing.
-->
<!ELEMENT response-router ((endpoint)*,(global-endpoint)*,(router)*)>

<!--
   This attibute defines the response transformers (if any) that will be applied
   to the response message before returning to the client. Developers can define
   a response-router with only a transformer and no actual routers to configure a
   response transformer.  Note that the connector can have a default Response transformer
   associated with it meaning that marshaling from transport specific MEssage types such as
   Jms will be done automatically.
-->
<!-- This has been removed as you can now set the response router on the endpoint -->
<!--<!ATTLIST response-router transformers              CDATA           #IMPLIED>-->

<!--
    Defines the timeout for routers configure on this response-router
-->
<!ATTLIST response-router timeout        CDATA         #IMPLIED>

<!--
//TODO
If a timeout occurs, should an error be thrown or allow the events to be passed on regardless
-->
<!--<!ATTLIST response-router failOnTimeout        (true | false)         "true">-->


<!--
A catch-all-strategy is invoked to route an event when an event is not accepted by any of the configured
routers.
-->
<!ELEMENT catch-all-strategy ((endpoint?|global-endpoint?), (properties)?)>

<!--
endpoint
Refers to an optional uri that can be resolvered as a provider.  This attribute functions the same
way as the provider attribute
-->

<!--
className
Is a fully qualified class name of the catch all strategy class
-->
<!ATTLIST catch-all-strategy className                  NMTOKEN           #REQUIRED>

<!--
    A router with route an event based on some criteria configured by the route, this criteria may be based
    on the content of the event, the type of event, metadata, etc.
    It is possible to chain routers together to combine different routing logic to a single
    event.  to chain routers you must define once router inside another.
-->

<!ELEMENT router (endpoint*, global-endpoint*, reply-to?, transaction?, filter?, properties?)>

<!--
    className
    A fully qualified class name of the Router to use.  Implementations must
    use org.mule.umo.routing.UMOOutboundRouter
-->

<!ATTLIST router className                   NMTOKEN           #REQUIRED>


<!--
    enableCorrelation
    This is used by outbound routers to determine if a correlationId should be set
    on the message being routed.  By default the correlationId is set as the current
    message id
-->

<!ATTLIST router enableCorrelation           (ALWAYS | NEVER | IF_NOT_SET)           "IF_NOT_SET">

<!--
    transformer
    This is the transformer chain to apply to the message before it is checked for a match.  This is useful
    where you want to filter on a subset of the message and cannot query it using a filter.
-->
<!ATTLIST router transformer           CDATA           #IMPLIED>

<!--
    propertyExtractor
    Is a fully qualified classname of a class that implements org.mule.util.properties.PropertyExtractor
    This object will be used to extract properties such as CorrelationId from the incoming message
-->
<!ATTLIST router propertyExtractor           NMTOKEN                                #IMPLIED>

<!ELEMENT reply-to EMPTY>

<!--
    address
    A replyTo address that should be used once a message has been processed.  This
    property only applies to outbound-routers.
-->

<!ATTLIST reply-to address                   CDATA           #REQUIRED>

<!--
    filters are used to determine whether the router should accept the current
    message.
    Note that any properties on the filter can be set by setting attributes
    on the filter element. The properties names are the bean properties names
    without the  'set'.
    You can also define two filters on a filter, the left filter and right filter
    these can be used when using logic filters to join filters.
-->

<!ELEMENT filter (properties?, filter?, left-filter?, right-filter?)>

<!--
    className
    A fully qualified class name of the Filter to use.  Implementations must
    use org.mule.umo.UMOFilter.
-->

<!ATTLIST filter className                   NMTOKEN           #REQUIRED>

<!--
because I can't find a way of allowing arbitary attributes on an element,
I am going to define a common set of attributes for filters but users can add their own
or relax dtd validation on their parser
Since Mule 1.1: Arbitary bean properties can be set on a filter using the
<properties> element. The parameters listed below on the filter still work and provider a
short hand way of setting these properties
-->
<!ATTLIST filter pattern                   CDATA           #IMPLIED>
<!ATTLIST filter expression                CDATA           #IMPLIED>
<!ATTLIST filter configFile                CDATA           #IMPLIED>
<!ATTLIST filter expectedType              CDATA           #IMPLIED>
<!ATTLIST filter path                      CDATA           #IMPLIED>

<!-- see explanation for 'filter' element -->
<!ELEMENT left-filter (properties?, filter?, left-filter?, right-filter?)>

<!-- see explanation for 'filter' element -->
<!ATTLIST left-filter className                   NMTOKEN           #REQUIRED>
<!--
because I can't find a way of allowing arbitary attributes on an element,
I am going to define a common set of attributes for filters but users can add their own
or relax dtd validation on their parser
-->
<!ATTLIST left-filter pattern                   CDATA           #IMPLIED>
<!ATTLIST left-filter expression                CDATA           #IMPLIED>
<!ATTLIST left-filter configFile                CDATA           #IMPLIED>
<!ATTLIST left-filter expectedType              CDATA           #IMPLIED>
<!ATTLIST left-filter path                      CDATA           #IMPLIED>

<!-- see explanation for 'filter' element -->
<!ELEMENT right-filter (properties?, filter?, left-filter?, right-filter?)>

<!-- see explanation for 'filter' element -->
<!ATTLIST right-filter className                   NMTOKEN           #REQUIRED>
<!--
because I can't find a way of allowing arbitary attributes on an element,
I am going to define a common set of attributes for filters but users can add their own
or relax dtd validation on their parser
-->
<!ATTLIST right-filter pattern                   CDATA           #IMPLIED>
<!ATTLIST right-filter expression                CDATA           #IMPLIED>
<!ATTLIST right-filter configFile                CDATA           #IMPLIED>
<!ATTLIST right-filter expectedType              CDATA           #IMPLIED>
<!ATTLIST right-filter path                      CDATA           #IMPLIED>

<!--
  Interceptors can be executed in sequence before and/or after the Mule component.
  -->

<!ELEMENT interceptor (properties?)>

<!--
    The fully qualified class name of the interceptor to use. This must implement
      <i>org.mule.UMOInterceptor</i>.

-->
<!ATTLIST interceptor className             NMTOKEN         #IMPLIED>

<!--
    The name of a registered interceptor stack.

-->
<!ATTLIST interceptor name             NMTOKEN         #IMPLIED>

<!--
  An exception strategy overrides the default exceptionStrategy in order to control the
  exception handling beaviour in the system. The class specified must implement
  <i>org.mule.exception.ExceptionStrategy</i>.
  -->

<!ELEMENT exception-strategy (endpoint*, global-endpoint*, properties?)>

<!--
    An endpoint to dispatch ExceptionMessages (including the Message being processed)
-->

<!--
    The fully qualified class name of the exception handler to use. This must implement
      org.mule.exception.ExceptionHandler.

-->
<!ATTLIST exception-strategy className             NMTOKEN         #REQUIRED>

<!--
          A collection of properties for the parent component
-->

<!ELEMENT properties ((property | factory-property | container-property | system-property | map | list | file-properties | text-property)*)>

<!--
          An property element allows arbitrary name/value pairs.
-->

<!ELEMENT property EMPTY>

<!--
    The name identifies the name of the attribute.
-->

<!ATTLIST property name             CDATA        #REQUIRED>
<!--
    The value identifies the value of the attribute.
-->
<!ATTLIST property value             CDATA        #REQUIRED>

<!--
          An property element allows for an object to be constructed based on the fully
        qualified classname in the factory attribute.
        Note that if the class specified extends <i>org.mule.config.PropertyFactory</a> the factory
        will be used to create the object.
-->

<!ELEMENT factory-property EMPTY>

<!--
    The name identifies the name of the attribute.
-->

<!ATTLIST factory-property name             CDATA        #REQUIRED>
<!--
    A fully qualified classname of the factory to use.
-->
<!ATTLIST factory-property factory             CDATA        #REQUIRED>

<!--
      A property element allows properties to be set from from an IoC contianer
    configured on the Model
-->

<!ELEMENT container-property EMPTY>

<!--
    The name identifies the name of the attribute on the current object
-->

<!ATTLIST container-property name             CDATA        #REQUIRED>
<!--
    The key identifier for the object to use in the container
-->
<!ATTLIST container-property reference             CDATA        #REQUIRED>

<!--
    The container name to look up the reference in.  If this is not
    specified all containers are queried.  An exception will be thrown
    if this property is set but the reference was not found in the container
-->
<!ATTLIST container-property container             CDATA        #IMPLIED>

<!--
    Whether an exception should be thrown if the component is not in the container.
    the default is true
-->
<!ATTLIST container-property required             (true | false)        "true">
<!--
      A property element allows properties to be set from the System properties
-->

<!ELEMENT system-property EMPTY>

<!--
    The name identifies the name of the attribute on the object being configured
-->

<!ATTLIST system-property name             CDATA        #REQUIRED>

<!--
The system property key to use when lookin up the property
-->
<!ATTLIST system-property key             CDATA        #REQUIRED>
<!--
    The default value will be used of the system property is not set.
-->
<!ATTLIST system-property defaultValue             CDATA        #IMPLIED>
<!--
    Defines a set of properties for a map property
-->
<!ELEMENT map ((property | factory-property | container-property | system-property | map | list | file-properties)*)>

<!--
    the name of the map property
-->
<!ATTLIST map name                    CDATA        #REQUIRED>

<!--
    Defines a list of properties for a list property
-->
<!ELEMENT list ((entry | factory-entry | system-entry | container-entry)*)>

<!--
    the name of the list property
-->
<!ATTLIST list name                    CDATA        #REQUIRED>

<!--
    Defines an entry for a list or array property
-->
<!ELEMENT entry EMPTY>

<!--
    the value of the entry
-->
<!ATTLIST entry value                    CDATA        #REQUIRED>

<!--
    Defines an factory entry for a list or array property
-->
<!ELEMENT factory-entry EMPTY>

<!--
    the factory class to use to create the entry
-->
<!ATTLIST factory-entry    factory                NMTOKEN        #REQUIRED>

<!--
    Defines an entry for a list or array property where the value is obtained
    from a container such as Spring
-->
<!ELEMENT container-entry EMPTY>

<!--
    the reference of the object in the container
-->
<!ATTLIST container-entry reference                    CDATA        #REQUIRED>

<!--
    determines if the object must be present in the container for configuration to
    succeed
-->
<!ATTLIST container-entry required                    (true | false)        "true">
<!--
    Defines an entry for a list or array property
-->
<!ELEMENT system-entry EMPTY>

<!--
    the key of the system property
-->
<!ATTLIST system-entry key                        CDATA        #REQUIRED>

<!--
    a default value if the property is not found
-->
<!ATTLIST system-entry defaultValue            CDATA        #IMPLIED>

<!--
    Loads properies from a java.properties file
-->
<!ELEMENT file-properties EMPTY>

<!--
    The path to the properties file on the classpath or local file system
-->
<!ATTLIST file-properties location                    CDATA        #REQUIRED>

<!--
Whether the properties in the properties file override properties already set on this object
-->
<!ATTLIST file-properties override                    (true | false)        "true">

<!--
          An property element allows to embed arbitary text as a property, such as script or xml
-->

<!ELEMENT text-property (#PCDATA)>

<!--
    The name identifies the name of the attribute.
-->

<!ATTLIST text-property name             CDATA        #REQUIRED>


<!--
    Optional description of the enclosing element.
    Used for user documentation of XML bean definition documents.
-->
<!ELEMENT description (#PCDATA)>
